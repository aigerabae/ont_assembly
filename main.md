```errors
(base) aygera@aygera-HP-Z6-G4-Workstation:~/Downloads/RN_ONT$ cp -r 15022024/ ~/biostar/RN/
cp: error reading '15022024/150224_RK_fasta/barcode64/FAS90246_pass_barcode64_061fc2eb_41692f9c_35_reads.fasta': Input/output error
cp: error reading '15022024/150224_RK_fasta/barcode24/FAS90246_pass_barcode24_061fc2eb_41692f9c_16_reads.fasta': Input/output error
cp: error reading '15022024/150224_RK_fasta/barcode36/FAS90246_pass_barcode36_061fc2eb_41692f9c_0_reads.fasta': Input/output error
cp: error reading '15022024/150224_RK_fasta/barcode19/FAS90246_pass_barcode19_061fc2eb_41692f9c_3_reads.fasta': Input/output error
cp: error reading '15022024/150224_RK_fasta/barcode19/FAS90246_pass_barcode19_061fc2eb_41692f9c_13_reads.fasta': Input/output error
cp: error reading '15022024/150224_RK_fasta/barcode38/FAS90246_pass_barcode38_061fc2eb_41692f9c_9_reads.fasta': Input/output error
cp: error reading '15022024/150224_RK_fasta/barcode38/FAS90246_pass_barcode38_061fc2eb_41692f9c_3_reads.fasta': Input/output error
cp: error reading '15022024/150224_RK_fasta/barcode38/FAS90246_pass_barcode38_061fc2eb_41692f9c_12_reads.fasta': Input/output error
cp: error reading '15022024/150224_RK_metaFlye-20240301T075028Z-001/barcode70/20-repeat/read_alignment_dump': Input/output error
```

I will run CAP3 on fastq data to assemble it again.
After clearing up some question, here are the objectives:
1) because it's mostly eDNA, the problematic barcodes are the ones that made 1 big sequence, rather than many small ones
2) need to use software that allows fir multiple sequences with multiplex amplicons
3) the end result needs to be consistent with lines showin on gel electrophoresis
4) only use barodes 1 to 70 as bases were not called for the rest of them
5) need to merge all fastq files per barcode (because each contains only up to 4000 reads)

Worflow:
1) sequencing = MinKNOW (ONT device control software) -> fast5 files (squiggle data / chromatogram peaks / raw data)
2) basecalling = Dorado (integrated with MinKNOW) -> fastq (raw sequences with quality scores)


Options:
- https://epi2me.nanoporetech.com/wfindex/ = doesn't work because their amplicon assembly mode works only for a single amplicon per barcode  
- https://github.com/GaetanBenoitDev/metaMDBG = state of the art tool for metagenome assembly  
- SemiBin2 and other binnign software tools = don't use it; only suitable for assemblying near whole genomes from eDNA assembled contigs  
- https://pmc.ncbi.nlm.nih.gov/articles/PMC6503943/#sec2  

The fastq files generated by the ONT software MinKNOW were de-multiplexed using MiniBar (see description below), with index edit distances of 2, 3, and 4 and a primer edit distance of 11. Next, the reads were filtered for quality (>13) and size (>3 kb) using Nanofilt [38, 39]. Individual consensus sequences were created using Allele Wrangler [40] for demultiplexed fastq files with a minimum coverage of 30. Error correction was performed using RACON [41, 42]. To do so, we first mapped all the reads back to the consensus using minimap [43]. We performed two cycles of running minimap and RACON. Final consensus sequences were compared against the National Center for Biotechnology Information database using Basic Local Alignment Search Tool n (BLASTn) to check if the taxonomic assignment was correct.

- https://academic.oup.com/gigascience/article/7/12/giy140/5202451?utm_source=chatgpt.com&login=true  
To enable fully reference-free analyses, we developed the nanoClust algorithm, which takes the fasta file of chopSeq-corrected reads as input and then performs read partitioning-based de novo clustering using VSEARCH [29] to delineate OTUs at a user-specified sequence similarity threshold (i.e., 97% in this study) followed by within-OTU read alignment and consensus calling for each OTU. The nanoClust algorithm is written in python, relies on Biopython packages, and was explicitly designed for de novo clustering because standard de novo clustering approaches such as VSEARCH [29] and the clustering approaches available in mothur [30, 31] vastly overestimated the richness of the mock community when using chopSeq-corrected reads (see details below). The nanoClust algorithm takes chopSeq-corrected reads in fasta format; splits the reads into partitions based on user-defined partition size; implements VSEARCH [29] for dereplication, chimera detection and removal in each partition, and clustering for each partition to identify the partition category with optimal (i.e., maximum) number of OTUs (not counting singleton OTUs); and discards singletons. Following this, nanoClust extracts read IDs for each OTU bin from the best-performing partition. The extracted read IDs for each OTU bin are then used to obtain full-length chopSeq-corrected reads; a subset of reads that fall within 10% of the average full-length read distribution within each OTU bin are aligned using Multiple Alignment using Fast Fourier Transform (MAFFT) [32, 33] with G-INS-i option, followed by consensus calling to obtain full-length representative sequence for each OTU. The entire data processing workflow is shown in Fig. 3.

- https://www.nature.com/articles/s41592-020-01041-y#Sec7 = Uses UMIs so the workflow would have to be altered
- NanoCLUST: a species-level analysis of 16S rRNA nanopore sequencing data = https://academic.oup.com/bioinformatics/article/37/11/1600/5929694?login=true = construction of a polished read and subsequent and Blast classification for  amplicon-based full-length 16S rRNA nanopore reads
??? I'm condused, are they the same thing or different??? with the previous
- 
